# 操作数据库

## Django配置连接数据库

在操作数据库之前，首先要连接数据库。这我们以配置`MySQL`为例来讲解。`Django`连接数据库，不需要单独的创建一个连接对象。只需要在`settings.py`文件中做好数据库相关的配置就可以了。示例如下：
```python
    DATABASES ={
        'default':{
            # 数据库引擎（是mysql还是oracle等）
            'ENGINE': 'django.db.backends.mysql',
            # 数据库的名字
            'NAME': 'abc',
            # 连接mysql数据库的用户名
            'USER': 'root',
            # 连接mysql的数据的密码
            'PASSWORD': '12345678',
            # mysql数据库的主机地址
            'HOST': '127.0.0.1',
            # mysql数据库的端口号
            'PORT':'3306',
        }
    }
```

## 在Django中操作数据库

在`Django`中操作数据库有两种方式。第一种方式是使用原生`sql`语句操作；第二种就是使用`ORM`模型来操作。这节首先来讲第一种。
在`Django`中使用原生`sql`语句操作其实就是使用`python db api`的接口来操作。如果你的`mysql`驱动使用的是`pymysql`，那么你就是使用`pymysql`来操作，只不过`Django`将数据库连接的这一部分封装好了，我们只要在`settings.py`中配置好的数据库连接信息直接使用`Django`封装好的接口就可以操作了。示例如下 ：
```python
    # 使用django封装好的connection对象，会自动读取settings.py中的数据库配置信息
    from django.db import connection
    
    # 获取游标对象
    cursor = connection.cursor()
    # 拿到游标对象后执行sql语句
    cursor.execute("select * from book")
    # 获取所有的数据
    rows = cursor.fetchall()
    # 遍历查询到的数据
    for row in rows:
        print(row)
```
以上`execute`以及`fetchall`方法都是`Python DB API`规范中定义好的。任何使用`Python`来操作`MySQL`的驱动程序者应该遵循这个规范。所以不管是用`pymysql`或是`mysqlclient`或`mysqldb`,他们的接口都是一样的。更多的规范请参考：[https://www.python.org/dev/peps/pep-0249/#cursor-methods](https://www.python.org/dev/peps/pep-0249/#cursor-methods)

## Python DB API下规范下cursor对象常用接口

1. `description`:如果`cursor`执行了查询的`sql`代码。那么读取`cursor.description`属性的时候，将返回一个列表，这个列表中装的是元组，元组中装的分别是`(name,type_code,display_size,internal_size,precision,scale,null_ok)`，其中`name`代表的是查找出来的数据的字段名称，其他参数暂时用处不在。
2. `rowcount`:代表的是在执行了`sql`语句后受影响的行数。
3. `close`: 关闭游标，关闭游标之后再也不能使用了，否则会抛出异常。
4. `execute(sql[, parameters])`：执行某个`sql`语句。如果在执行`sql`语句的时候还需要传递参数，那么可以传给`parameters`参数，示例代码如下：
```sql
    cursor.execute("select * from article where id=%s",(1,))
```
5. `fetchone`: 在执行了查询操作以后，获取第一条数据。
6. `fetchmany(size)`: 在执行查询操作以后，获取多条数据，具体是多少条要看传的`size`参数。如果不传`size`参数，那么默认是获取第一条数据。
7. `fetchall`：获取所有满足`sql`语句的数据。
# ORM模型介绍

随着项目越来越大，采用写原生**SQL**的方式在代码中分出现大量的**SQL**语句，那么问题就出现了：
1. **SQL**语句的重复利用率不高，起复杂的**SQL**语句条件越多，代码越长。会出现很多相近的**SQL**语句。
2. 很多**SQL**语句是在业务逻辑中拉出来的，如果有数据库需要更改，就要去修改这些逻辑，这会很容易漏掉对某些**SQL**语句的修改。
3. 写**SQL**时容易忽略**Web**安全问题，给未来造成隐患，**SQL**注入。
4.`ORM`，全称`Object Relational Mapping`，中文称为**对象关系映射**，通过`ORM`我们可以通过类的方式去操作数据库，而不用写原生的**SQL**语句。通过把表映射成类，把行作实例，把字段作为属性，`ORM`在执行对象操作的时候最终还是会把对应的操作转换为数据库原生语句。使用`ORM`有许多优点：
1. 易用性：使用`ORM`做数据库的开发可以有效的减少重复**SQL**语句的概率，写出来的模型也更加直观、清晰。
2. 性能损耗小：`ORM`转换成底层数据库操作指令确实会有一些开销。全从实际的情况来看，这种性能损耗很少（不足5%），只要不是对性能有严苛的要求，综合考虑开发效率、代码的阅读性，带来的好处要远远大于性能损耗，而且项目越大作用越明显。
3. 设计灵活：可以轻松的写出复杂的查询。
4. 可移植性：`Django`封装了底层的数据库实现，支持多个关系数的引擎，包括流行的`MySQL`、`PostgreSQL`和`SQLite`。可以非常轻松的切换数据库。
![ORM](http://ww1.sinaimg.cn/large/006k72Wegy1fpq8p75pnaj30go0akt9b.jpg)


# 创建ORM模型

`ORM`模型一般都放在`APP`的`models.py`文件中，每个`APP`都可以拥有自己的模型。并且如果这个模型想要映射到数据库中，那么这个`APP`必须放在`settings.py`的`INSTALLED_APP`中进行安装。示例如下：
```python
    from django.db import models
    
    class Book(models.Model):
        name = models.CharField(max_length=20,null=False)
        author = models.CharField(max_lenght=20,nullFalse)
        pub_date = models.DateTimeField(default=datetime.now)
        price = models.FloatField(default=0)
```
以上是定义了一个模型。这个模型继承`django.db.models.Model`，如果这个模型想要映射到数据库中，就必须继承自这个类。这个模型以后映射到数据库中，表名是模型名称的小写形式，为`book`。在这个表中，有四个字段，一个为`name`，这个字段保存是书的名称，是`varchar`类型，最长不能超过20个字符 ，并且不能为空。第二个字段是作者名字，同样是`varchar`类型，最长不能超过20个字符 ，并且不能为空。第三个字段是出版时间，数据类型是`datetime`类型，默认是保存这本书的时间。第五个字段是本书的价格，是浮点类型。
还有一个字段我们没有写，就是主键`id`，在`Django`中，如果一模型没有定义主键，那么将会自动生成一个自动增长的`int`类型的主键，并且这个主键的名字为`id`。

# 映射模型到数据库中

将`ORM`模型映射到数据库中，总结起来就是以下几步：
1. 在`settings.py`中，配置好`DATABASES`，做好数据库相关配置。
2. 在`APP`中的`models.py`中定义好模型，这个模型必须继承自`django.db.models.Model`。
3. 将这个`APP`添加到`settings.py`的`INSTALLED_APP`中。
4. 在命令行终端，进入到项目所在的路径，然后执行命令`python manage.py makemigrations`来生成迁移脚本文件。
5. 同样的在命令中，执行命令`python manage.py migrate`来将迁移脚文件映射到数据库中。# 模型常用字段

## 常用字段

在`Django`中，定义了一些`Field`来与数据库表中的字段类型进行映射。以下将介绍那些常用的字段类型。

### AutoField

映射到数据库中的`int`类型，可以有自动增长的特性，一般不需要使用这个类型。如果不指定主键，那么模型会自动的生成一个叫做`id`的自动增长的主键。如果你想指定一个其名字的并且具有自动增长的主键，使用`AutoField`也是可以的。

### BigAutoField

64位的整形，类似于`AutoField`，只不过是产生的数据范围是从`1-9223372036854775807`。

### BooleanField

在模型层接收的是`True/False`，在数据库层而是`tinyint`类型。如果没有指定默认值，默认值是`None`。

### CharField

在数据库层面是`varchar`类型，在`Python`层面变是普通的字符串。**这个类型在使用的时候必须要指定最大的长度**,也即必须要传递`max_length`这个关键字参数进去。

### DateField

在使用`DataeField`之前，先需要了解两个概念

#### navie时间

`navie`时间：不知道自己的时间表示的是哪个时区的。

#### aware时间

`aware`时间：带时区的时间

#### pytz库

专门用来处理时区的库，这个库经常会更新一些时区的数据，这个库在安装`Django`的时候会默认的安装。

#### astimezone方法

将一个时区的时间转换成另一个时区的时间。这个方法只能被`aware`类型的时间调用，不能被`navie`类型的时间调用。

```python
import pytz
from datetime import datetime

now = datetime.now()
utc_timezone=pytz.timezone('UTC')
bj_timezone=pytz.timezone('Asia/Shanghai')
now_utc.astimezone(bj_timezone)

```

#### replace方法

可以将一个时间的某些属性进行更改

```python
In [23]: now                                                                                                
Out[23]: datetime.datetime(2018, 10, 23, 14, 53, 29, 361613)

In [24]: now = now.replace(tzinfo=pytz.timezone("Asia/Shanghai"))                                           

In [25]: now                                                                                                
Out[25]: datetime.datetime(2018, 10, 23, 14, 53, 29, 361613, tzinfo=<DstTzInfo 'Asia/Shanghai' LMT+8:06:00 STD>)
```

#### django.utils.timezone.now()方法

1. 在`settings.py`配置文件中，如果`USE_TZ = True`, 此方法获取的是`aware`类型的时间，时间的时区是`UTC`，即
`2018-10-23 07:47:03.751990+00:00`。

2. 在`settings.py`配置文件中，如果`USE_TZ = False`,此方法获取的是`navie`类型的时间，即`datetime.now()`。

#### django.utils.timezone.localtime方法

1. 在`settings.py`配置文件中，如果`USE_TZ = True`, 此方法获取的是`aware`类型的时间，时间的时区是`settingspy`中设置的`TIME_ZONE`，即
`2018-10-23 15:47:03.751990+08:00`。

2. 在`settings.py`配置文件中，如果`USE_TZ = False`,此方法不可用。如果用会报错`localtime() cannot be applied to a naive datetime`

#### navie和aware介绍以及在django中的用法

[https://docs.djangoproject.com/en/2.1/topics/i18n/timezones/](https://docs.djangoproject.com/en/2.1/topics/i18n/timezones/)

日期类型，在`Python`中是`datetime.date`类型，可以记录年月日。在映射到数据库中也`date`类型，使用这个`Field`可以传递以下几个参数：
1. `auto_now`：在每次这个数据保存的时候，都使用当前的时间。比如做为一个记录修改日期的字段，可以将这个属性设置为`True`。
2. `auto_now_add`：在每次数据第一次被添加进行的时候，都使用当前的时间，比如作为一个记录第一次入库的字段，可以将这个属性设置为`True`。

### DateTimeField

日期时间类型，类似于`DateField`，不仅仅可以存储日期，还可以存储时间。映射到数据库中是`datetime`类型。这个`Field`也可以用`auto_now`和`auto_now_add`这两个属性。

1. `auto_now_add=True`: 是在第一交从汪厍数据进去的时候自动获取当前的时间

2. `auto_now=True`: 每次这个对象调用save方法的时候都会将当前的时间更新

### TimeField

时间类型，在数据库中是`time`类型，在`Python`中是`datetime.datetime`类型。

### EmailField

类似于`CharField`，在数据库底层也是一个`varchar`类型，最大长度是**254**个字符。

### FileField

用来存储文件的，这个可以参考后面的文件上传章节部分。

### ImageField

用来存储图片文件的，这个可以参考后面的图片上传章节部分。

### FloatField

浮点类型，映射到数据库中是`float`类型。

### IntegerField

整形，值的区间：`-2147483648-2147483647`。

### BigIntegerField

大整形，值的区间：`-9223372036854775808-9223372036854775807`。


### PositiveIntegerField

正整形，值的区间：`0-2147483647`。

### SmallIntegerField

小整形，值的区间：`-32768-32767`。

### PositiveSmallIntegerField

正小整形，值的区间：`0-32767`。

### TextField

大量的文本类型，映射到数据库中的是`longtext`类型。

### UUIDField

只能存储`uuid`格式的字符串，`uuid`是一个**32**位的全球唯一的字符串，一般用来作为主键。

### URLField

类似于`CharField`，只不过只能用来存储`url`格式的字符串，并且默认的`max_length`是**200**。


## Field的常用参数

### null

如果设置为`True`，`Django`将会映射表的时候指定是否为空。默认是`False`。在使用字符串相关的`Field`**（CharField/TextField）**的时候，官方推荐尽量不要使用这个参数，也就是保持默认值`False`。因为`Django`在处理字符串相关的`Field`的时候，即使这个`Field`的`null=False`，如果你没有给这个`Field`传递任何值，那么`Django`也会傅一个空的字符串`""`来作为默认值存储进去。因此如果再使用`null=True`，`Django`会产生两种空值的情况(**NULL**或空字符串).如果想要在表单验证的时候允许这个字符串为空，那么建议使用`blank=True`。如果你的`Field`是`BooleanField`，那么对就的可空的字段则为`NullBooleanField`。

### blank

标识这个字段在表单验证的时候是否可以为空。默认为`False`。这个和`null`是有区别的，`null`是一个纯数据库级别的。而`blank`是表单验证级别的。

### db_column

这个字段在数据库中的名字。如果没有设置这个参数，那么将会使用模型中属性的名称。

### default

默认值，可以为一个值，或一个函数，但不支持`lambda`表达式。并且不支持列表/字典/集合等可变的数据结构 。

### primary_key

是否为主键，默认是`False`。

### unique

在表中这个字段的值是否唯一，一般是设置手机号/邮箱等。

更多`Feild`参数请参考官方文档：
[https://docs.djangoproject.com/zh-hans/2.1/ref/models/fields/](https://docs.djangoproject.com/zh-hans/2.1/ref/models/fields/)

# 模型中`Meta`配置

对于一些模型级别的配置，我们可以在模型中定义一个类，叫做`Meta`。然后在这个类中清加一些类属性来控制模型的作用。比如我们杨要在数据库映射的时候使用自己指定的表名，而不是使用模型的名称。那么我们可以在`Meta`类中添加一个`db_table`的属性。示例代码如下：
```python
    class Book(models.Model):
        name = models.CharField(max_length=20,null=False)
        desc = models.CharField(max_length=100,name='description',db_column='description1')
        
        class Meta:
            db_table = 'book_model'
```
以下将对`Meta`类中的一些常用配置进行解释。


### db_table

这个模型映射到数据库中的表名，如果没有指定这个参数，那么在映射的时候会使用模型名来作为默认的表名。

### ordering

设置在提取数据的排序方式，后面章节中会讲到如何查找数据。比如我想在查找数据的时候根据添加的时间排序，示例如下：
```python
    class Book(models.Model):
        name = models.CharField(max_length=20,null=False)
        desc = models.CharField(max_length=100,name='description',db_column='description1')
        pub_date = models.DateTimeField(auto_now_add=True)
        
        class Meta:
            db_table = 'book_model'
            ordering = ['pub_date']
```
更多的配置后面会慢慢介绍到，官方文档：
[https://docs.djangoproject.com/en/2.1/ref/models/options/](https://docs.djangoproject.com/en/2.1/ref/models/options/)




# 外键和表关系

## 外键

在`MySQL`中，表有两种引擎，一种是`InnoDB`，另外一种是`myisam`。如果使用的是`InnoDB`引擎，是支持外键约束的。外键的存在使得`ORM`框架在处理表关系的时候异常的强大。因此这里我们首先来介绍下外键在`Django`中的使用。
类定义为`class ForeignKey(to,on_delete,**options)`。第一个参数是引用的哪个模型，第二个参数是在使用外键引用的模型数据被删除了，这个字段该如何处理，比如有`CASCADE`、`SET_NULL`等。这里以一个实际案例来说明。比如有一个`User`和一个`Article`两个模型。一个`User`可以发表多篇文章，一个`Article`只能有一个`Author`，并且通过外键进行引用。示例代码如下：
```python
    class User(models.Model):
    username = models.CharField(max_length=20)
    password = models.CharField(max_length=100)


    class Article(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
    
        author = models.ForeignKey("User",on_delete=models.CASCADE)
```
以上使用`ForeignKey`来定义模型之间的关系。即在`article`的实例中可以通过`author`属性来操作对应的`User`模型。这样使用起来非常方便。示例如下：
```python
    from blog.models import User,Article
    
    author = User(username='张三',password='123456')
    author.save()
    
    article = Article(title='abc',content='123')
    article.author=author
    article.save()
```
为什么使用了`ForeignKey`后，就能通过`author`访问到对应的`user`对象呢。因此在底层，`Django`为`Article`表添加一个`属性名_id`的字段（比如**author**的字段名称为**author_id**)，这个字段是一个外键，记录着对应的作者的主键。以后通过`article.author`访问的时候，实际上是先通`author_id`找到对应的数据，然后再提取`User`表中的这条数据，形成一个模型。

如果想要引用另外一个`APP`的模型，那么应该在传递`to`参数的时候，使用`app.model_name`进行指定。以上例为例，如果`User`和`Article`不是在同一个`APP`中，那么在引用的时候示例代码如下：
```python
    # User模型在user这个app中
    class User(models.Model):
        username = models.CharField(max_length=20)
        password = models.CharField(max_length=100)
    
    # Article模型在article这个app中
    class Article(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
        
        author = models.ForeignKey("user.User",on_delete=models.CASCADE)
```
如果模型的外键引用的是本身自己这个模型，那么`to`参数可以为`self` ，或者是这个模型的名字。在论坛开发中，一般评论都可以进行二级评论，即可以针对另外一个评论进行评论，那么在定义模型的时候就需要使用外键来引用自身。示例代码如下：
```python
    class Comment(models.Model):
    content = models.TextField()
    origin_comment = models.ForeignKey('self',on_delete=models.CASCADE,null=True)
    
    # 或者
    # origin_comment = models.ForeignKey('Comment',on_delete=models.CASCADE,null=True)
```
## 外键删除操作

如果一个模型使用了外键。那么在对方那个模型被删掉后，该进行什么样的操作。可以通过 on_delete 来指定。可以指定的类型如下：
1. CASCADE ：级联操作。如果外键对应的那条数据被删除了，那么这条数据也会被删除。
2. PROTECT ：受保护。即只要这条数据引用了外键的那条数据，那么就不能删除外键的那条数据。
3. SET_NULL ：设置为空。如果外键的那条数据被删除了，那么在本条数据上就将这个字段设置为空。如果设置这个选项，前提是要指定这个字段可以为空。
4. SET_DEFAULT ：设置默认值。如果外键的那条数据被删除了，那么本条数据上就将这个字段设置为默认值。如果设置这个选项，前提是要指定这个字段一个默认值。
5. SET() ：如果外键的那条数据被删除了。那么将会获取 SET 函数中的值来作为这个外键的值。 SET 函数可以接收一个可以调用的对象（比如函数或者方法），如果是可以调用的对象，那么会将这个对象调用后的结果作为值返回回去。
6. DO_NOTHING ：不采取任何行为。一切全看数据库级别的约束。以上这些选项只是Django级别的，数据级别依旧是**RESTRICT**！

## 表关系

表之间的关系都是通过外键来进行关联的。而表之间的关系，无非就是三种关系：一对一、一对多（多对一）、多对多等。以下将讨论一下三种关系的应用场景及其实现方式。

### 一对多

1. 应用场景：比如文章和作者之间的关系。一个文章只能由一个作者编写，但是一个作者可以写多篇文章。文章和作者之间的关系就是典型的多对一的关系。
2. 实现方式：一对多或者多对一，都是通过`ForeignKey` 来实现的。还是以文章和作者的案例进行讲解。
```python
    class User(models.Model):
        username = models.CharField(max_length=20)
        password = models.CharField(max_length=100)
        
    class Article(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
        
        author = models.ForeignKey("User",on_delete=models.CASCADE)
```
那么以后在给 `Article `对象指定 `author `，就可以使用以下代码来完成：
```python
    article = Article(title='abc',content='123')
    author = User(username='zhiliao',password='111111')
    # 要先保存到数据库中
    author.save()
    article.author = author
    article.save()
```
并且以后如果想要获取某个用户下所有的文章，可以通过 `article_set `来实现。示例代码如下：
```python
    user = User.objects.first()
    # 获取第一个用户写的所有文章
    articles = user.article_set.all()
    for article in articles:
    print(article)
```

### 一对一

1. 应用场景：比如一个用户表和一个用户信息表。在实际网站中，可能需要保存用户的许多信息，但是有些信息是不经常用的。如果把所有信息都存放到一张表中可能会影响查询效率，因此可以把用户的一些不常用的信息存放到另外一张表中我们叫做 `UserExtension `。但是用户
表 `User `和用户信息表 `UserExtension `就是典型的一对一了。
2. 实现方式： `Django `为一对一提供了一个专门的 `Field `叫做 `OneToOneField `来实现一对一操作。示例代码如下：
```python
    class User(models.Model):
        username = models.CharField(max_length=20)
        password = models.CharField(max_length=100)
        
    class UserExtension(models.Model):
        birthday = models.DateTimeField(null=True)
        school = models.CharField(blank=True,max_length=50)
        user = models.OneToOneField("User", on_delete=models.CASCADE)
```
在 `UserExtension `模型上增加了一个一对一的关系映射。其实底层是在 `UserExtension `这个表上增加了一个 `user_id `，来和 `user `表进行关联，并且这个外键数据在表中必须是唯一的，来保证一对一。


### 对多对

1. 应用场景：比如文章和标签的关系。一篇文章可以有多个标签，一个标签可以被多个文章所引用。因此标签和文章的关系是典型的多对多的关系。
2. 实现方式： `Django `为这种多对多的实现提供了专门的 `Field `。叫做 `ManyToManyField `。还是拿文章和标签为例进行讲解。示例代码如下：
```python
    class Tag(models.Model):
        name = models.CharField(max_length=50)

    class Article(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
        tags = models.ManyToManyField("Tag",related_name="articles")
```
在数据库层面，实际上 `Django `是为这种多对多的关系建立了一个中间表。这个中间表分别定义了两个外键，引用到 `article `和 `tag `两张表的主键。


## related_name和related_query_name

### related_name

还是以 `User `和 `Article `为例来进行说明。如果一个 `article `想要访问对应的作者，那么可以通过 `author `来进行访问。但是如果有一个 `user `对象，想要通过这个 `user `对象获取所有的文章，该如何做呢？这时候可以通过 `user.article_set` 来访问，这个名字的规律是 `模型名字小写_set` 。示例代码如下：
```python
    user = User.objects.get(name='张三')
    user.article_set.all()
```
如果不想使用 `模型名字小写_set` 的方式，想要使用其他的名字，那么可以在定义模型的时候指定 `related_name `。示例代码如下：
```python
    class Article(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
        # 传递related_name参数，以后在方向引用的时候使用articles进行访问
        author = models.ForeignKey("User",on_delete=models.SET_NULL,null=True,related_name='articles')
```
以后在方向引用的时候。使用 `articles `可以访问到这个作者的文章模型。示例代码如下：
```python
    user = User.objects.get(name='张三')
    user.articles.all()
```
如果不想使用反向引用，那么可以指定 `related_name='+'` 。示例代码如下：
```python
    class Article(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
        # 传递related_name参数，以后在方向引用的时候使用articles进行访问
        author = models.ForeignKey("User",on_delete=models.SET_NULL,null=True,related_name='+')
```
以后将不能通过 `user.article_set` 来访问文章模型了。

### related_query_name

在查找数据的时候，可以使用 `filter `进行过滤。使用 `filter `过滤的时候，不仅仅可以指定本模型上的某个属性要满足什么条件，还可以指定相关联的模型满足什么属性。比如现在想要获取写过标题为 `abc `的所有用户，那么可以这样写：
```python
    users = User.objects.filter(article__title='abc')
```
如果你设置了 `related_name `为 `articles `，因为反转的过滤器的名字将使用 `related_name `的名字，那么上例代码将改成如下：
```python
    users = User.objects.filter(articles__title='abc')
```
可以通过 `related_query_name `将查询的反转名字修改成其他的名字。比如 `article `。示例代码如下：
```python
    class Article(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField()
        # 传递related_name参数，以后在方向引用的时候使用articles进行访问
        author = models.ForeignKey("User",on_delete=models.SET_NULL,null=True,related_name='articles',related_query_name='article')
```
那么在做反向过滤查找的时候就可以使用以下代码：
```python
    users = User.objects.filter(article__title='abc')
```

**注意**

1. `related_name`,反向引用（默认是`模型`小写化加上`_set`），即
```python
    # models.py
    Article(models.Model)
        author = models.ForeignKey("User",on_delete=models.SET_NULL,null=True,related_name='articles')
    
    # views.py
    user.articles.all()
```
某个`user`的所有`articles`。

2. `related_query_name`,反向过滤（反向查询），默认是`模型`小写化`article__in`，即
```python
    # models.py
    Article(models.Model)
        author = models.ForeignKey("User",on_delete=models.SET_NULL,related_query_name='articles')
    
    # views.py
    users = User.objects.filter(articles__title__contains='abc')
```
查询文章`title`包含`abc`的所有`user`。

# 模型的操作

在 `ORM `框架中，所有模型相关的操作，比如添加/删除等。其实都是映射到数据库中一条数据的操作。因此模型操作也就是数据库表中数据的操作。

## 添加一个模型到数据库中

添加模型到数据库中。首先需要创建一个模型。创建模型的方式很简单，就跟创建普通的 `Python `对象是一摸一样的。在创建完模型之后，需要调用模型的 `save `方法，这样 `Django `会自动的将这个模型转换成 `sql `语句，然后存储到数据库中。示例代码如下：
```python
    class Book(models.Model):
        name = models.CharField(max_length=20,null=False)
        desc = models.CharField(max_length=100,name='description',db_column="description1")
        pub_date = models.DateTimeField(auto_now_add=True)
        
    book = Book(name='三国演义',desc='三国英雄！')
    book.save()
```

### 查找数据

查找数据都是通过模型下的 `objects `对象来实现的。

### 查找所有数据

要查找 `Book `这个模型对应的表下的所有数据。那么示例代码如下：
```python
    books = Book.objects.all()
```
以上将返回 `Book `模型下的所有数据。

### 数据过滤

在查找数据的时候，有时候需要对一些数据进行过滤。那么这时候需要调用 `objects `的 `filter `方法。实例代码如下：
```python
books = Book.objects.filter(name='三国演义')
> [<Book:三国演义>]
# 多个条件
books = Book.objects.filter(name='三国演义',desc='test')
```
调用 `filter `，会将所有满足条件的模型对象都返回。

### 获取单个对象

使用 `filter `返回的是所有满足条件的结果集。有时候如果只需要返回第一个满足条件的对象。那么可以使用 `get `方法。示例代码如下：
```
book = Book.objects.get(name='三国演义')
> <Book:三国演义>
```
当然，如果没有找到满足条件的对象，那么就会**抛出一个异常**。而 `filter `在没有找到满足条件的数据的时候，是**返回一个空的列表**。

### 数据排序

在之前的例子中，数据都是无序的。如果你想在查找数据的时候使用某个字段来进行排序，那么可以使用 `order_by `方法来实现。示例代码如下：
```python
books = Book.objects.order_by("pub_date")
```
以上代码在提取所有书籍的数据的时候，将会使用 `pub_date `从小到大进行排序。如果想要进行倒序排序，那么可以在 `pub_date `前面加一个负号。实例代码如下：
```
books = Book.objects.order_by("-pub_date")
```

### 修改数据

在查找到数据后，便可以进行修改了。修改的方式非常简单，只需要将查找出来的对象的某个属性进行修改，然后再调用这个对象的 `save `方法便可以进行修改。示例代码如下：
```python
from datetime import datetime
book = Book.objects.get(name='三国演义')
book.pub_date = datetime.now()
book.save()
```

### 删除数据

在查找到数据后，便可以进行删除了。删除数据非常简单，只需要调用这个对象的 `delete `方法即可。实例代码如下：
```python
book = Book.objects.get(name='三国演义')
book.delete()
```# 查询操作

查找是数据库操作中一个非常重要的技术。查询一般就是使用 `filter `、 `exclude `以及 `get `三个方法来实现。我们可以在调用这些方法的时候传递不同的参数来实现查询需求。在 `ORM `层面，这、些查询条件都是使用 `field + __ + condition` 的方式来使用的。以下将那些常用的查询条件来一一解释。


## 查询条件

字段查询是指如何指定`SQL WHERE`子句的内容。它们用作`QuerySet`的`filter()，exclude()和get()`方法的关键字参数

|字段查询参数|说明|
|---|---|
|exact|	精确匹配|
|iexact|	不区分大小写的精确匹配|
|contains|	包含匹配|
|icontains|	不区分大小写的包含匹配|
|in|	在..之内的匹配|
|gt|	大于|
|gte|	大于等于|
|lt|	小于|
|lte|	小于等于|
|startswith|	从开头匹配|
|istartswith| 不区分大小写从开头匹配|
|endswith|	从结尾处匹配|
|iendswith|	不区分大小写从结尾处匹配|
|range|	范围匹配|
|date|	日期匹配|
|year|	年份|
|month|	月份|
|day|	日期|
|week|	第几周|
|week_day|	周几|
|time|	时间|
|hour|	小时|
|minute|	分钟|
|second|	秒|
|isnull|	判断是否为空|
|search|	1.10中被废弃|
|regex|	区分大小写的正则匹配|
|iregex|	不区分大小写的正则匹配|

### exact

使用精确的`= `进行查找。如果提供的是一个 `None `，那么在 `SQL `层面就是被解释为 `NULL `。示例代码如下：
```python
    article = Article.objects.get(id__exact=14)
    article = Article.objects.get(id__exact=None)
```
以上的两个查找在翻译为 SQL 语句为如下：
```sql
    select ... from article where id=14;
    select ... from article where id IS NULL;
```

如果使用`filter`则返回的是`QuerySet`，如果使用的是`get`则返回的是`Model`，没有`query`属性。
访问`QuerySet`实例的`query`属性，可以查看`ORM`将些查询转换的`SQL`。
```python
def index(request):
    article = Article.objects.filter(id__exact=1)
    print(article)
    print('*'*30)
    print(article.query)
    return HttpResponse("Success!")
    
# 显示的结果如下：
<QuerySet [<Article: 港珠澳大桥>]>
[25/Oct/2018 09:51:47] "GET / HTTP/1.1" 200 8
******************************
SELECT `article_article`.`id`, `article_article`.`title`, `article_article`.`content` FROM `article_article` WHERE `article_article`.`id` = 1
```

**注意**
在Windows操作系统上，`MySQL`的排序规则`collation`无论是什么都是大小写不敏感的。
在Linux操作系统上，`MySQL`的排序规则 `collation`是`utf8_bin`，那么是大小写敏感的。

### iexact

使用 `like `进行查找。示例代码如下：
```python
    article = Article.objects.filter(title__iexact='hello world')
```
那么以上的查询就等价于以下的 `SQL `语句：
```sql
    select ... from article where title like 'hello world';
```
注意上面这个 `sql `语句，因为在 `MySQL `中，没有一个叫做 `ilike `的。所以 `exact `和 `iexact `的区别实际上就是 `LIKE `和 `= `的区别，在大部分 `collation=utf8_general_ci` 情况下都是一样的（ `collation `是用来对字符串比较的）。

> `LIKE`和`=`:大部分情况下都是等价的，只有少数情况下是不等价的。
> `exact`和`iexact`: 区别就是`=`和`LIKE`的区别，因为`exact`会被`ORM`转换成`=`,`iexact`会被`ORM`转换成`LIKE`。


### contains

**大小写敏感**，判断某个字段是否包含了某个数据。示例代码如下：
```python
    articles = Article.objects.filter(title__contains='hello')
```
在翻译成 `SQL `语句为如下：
```sql
    select ... where title like LIKE BINARY '%hello%';
```
要注意的是，在使用 `contains `的时候，翻译成的 `sql `语句左右两边是有百分号的，意味着使用的是模糊查询。而 `iexact `翻译成 `sql `语句左右两边是没有百分号的，意味着使用的是精确的查询。

### icontains

**大小写不敏感**的匹配查询。示例代码如下：
```python
    articles = Article.objects.filter(title__icontains='hello')
```
在翻译成 `SQL `语句为如下：
```sql
    select ... where title like '%hello%';
```

在`MySQL`中`LIKE BINARY`是**区别大小写**的，而`LIKE`是**不区别分大小写**的

### in

提取那些给定的 `field `的值是否在给定的容器中。容器可以为 `list `、 `tuple `或者任何一个可以迭代的对象，包括 `QuerySet `对象。示例代码如下：
```python
    articles = Article.objects.filter(id__in=[1,2,3])
```
以上代码在翻译成 `SQL `语句为如下：
```sql
    select ... where id in (1,3,4)
```
当然也可以传递一个 `QuerySet `对象进去。示例代码如下：
```python
    inner_qs = Article.objects.filter(title__contains='hello')
    categories = Category.objects.filter(article__in=inner_qs)
```
以上代码的意思是获取那些文章标题包含 `hello `的所有分类。将翻译成以下 `SQL `语句，示例代码如下：
```sql
    select ...from category where article.id in (select id from article where title like '%hello%');
```

如果在做反向过滤的时候，过滤的字段是模型的主键，可以直接省略主键的字段，`article__id__in`可以写成`article__in` 。

### gt

某个 `field `的值要大于给定的值。示例代码如下：
```python
    articles = Article.objects.filter(id__gt=4)
```
以上代码的意思是将所有 id 大于4的文章全部都找出来。将翻译成以下 SQL 语句：
```sql
    select ... where id > 4;
```

### gte

类似于 `gt `，是大于等于。


### lt

类似于 `gt `,是小于。

### lte

类似于 `gt`, 是小于等于。

### startswith

判断某个字段的值是否是以某个值开始的。**大小写敏感**。示例代码如下：
```python
    articles = Article.objects.filter(title__startswith='hello')
```
以上代码的意思是提取所有标题以 `hello `字符串开头的文章。将翻译成以下 `SQL `语句：
```sql
    select ... where title LIKE BINARY 'hello%';
```

### istartswith

类似于 `startswith `，但是大小写是不敏感的。


### endswith

判断某个字段的值是否以某个值结束。大小写敏感。示例代码如下：
```python
    articles = Article.objects.filter(title__endswith='world')
```
以上代码的意思是提取所有标题以 `world `结尾的文章。将翻译成以下 `SQL `语句：
```sql
    select ... where title LIKE BINARY  '%world';
```

### iendswith

类似于 `endswith `，只不过大小写不敏感。


### range

判断某个 `field `的值是否在给定的区间中。示例代码如下：
```python
    from django.utils.timezone import make_aware
    from datetime import datetime
    
    start_date = make_aware(datetime(year=2018,month=1,day=1))
    end_date = make_aware(datetime(year=2018,month=3,day=29,hour=16))
    articles = Article.objects.filter(pub_date__range=(start_date,end_date))
```
以上代码的意思是提取所有发布时间在 `2018/1/1` 到 `2018/12/12` 之间的文章。将翻译成以下的 `SQL `语句：
```sql
    select ... from article where pub_time between '2018-01-01' and '2018-12-12';
```
需要注意的是，以上提取数据，**不会包含最后一个值**。也就是不会包含 2018/12/12 的文章。而且另外一个重点，因为我们在 `settings.py` 中指定了 `USE_TZ=True` ，并且设置了 `TIME_ZONE='Asia/Shanghai'` ，因此我们在提取数据的时候要使用 `django.utils.timezone.make_aware` 先将 `datetime.datetime` 从 `navie `时间转换为 `aware `时间。 `make_aware `会将指定的时间转换为 `TIME_ZONE `中指定的时区的时间。`range`接受的参数时间为须为`aware`时间类型。

### date

针对某些 `date `或者 `datetime `类型的字段。可以指定 `date `的范围。并且这个时间过滤，还可以使用链式调用。示例代码如下：
```python
    articles = Article.objects.filter(pub_date__date=date(2018,3,29))
```
以上代码的意思是查找时间为 `2018/3/29` 这一天发表的所有文章。将翻译成以下的 sql 语句：
```sql
    select ... WHERE DATE(CONVERT_TZ(`front_article`.`pub_date`, 'UTC', 'Asia/Shanghai')) =2018-03-29
```
注意，因为默认情况下 `MySQL `的表中是没有存储时区相关的信息的。因此我们需要下载一些时区表的文件，然后添加到 `Mysql `的配置路径中。如果你用的是 `windows `操作系统。那么在 [http://dev.mysql.com/downloads/timezones.html](http://dev.mysql.com/downloads/timezones.html) 下载 `timezone_2018d_posix.zip - POSIX standard` 。然后将下载下来的所有文件拷贝到 `C:\ProgramData\MySQL\MySQL Server5.7\Data\mysql` 中，如果提示文件名重复，那么选择覆盖即可。
如果用的是 `linux `或者 `mac `系统，那么在命令行中执行以下命令： `mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -D mysql -u root -p` ，然后输入密码，从系统中加载时区文件更新到 `mysql `中。

### year

根据年份进行查找。示例代码如下：
```python
    articles = Article.objects.filter(pub_date__year=2018)
    articles = Article.objects.filter(pub_date__year__gte=2017)
```
以上的代码在翻译成 SQL 语句为如下:
```sql
    select ... where pub_date between '2018-01-01' and '2018-12-31';
    select ... where pub_date >= '2017-01-01';
```
### month

同`year`，根据月份进行查找。

### day

同`year`，根据日期进行查找。

### week_day

`Django 1.11` 新增的查找方式。同 `year `，根据星期几进行查找。1表示星期天，7表示星期六， 2-6 代表的是星期一到星期五。

### time

根据时间进行查找。示例代码如下：
```python
    articles = Article.objects.filter(pub_date__time=datetime.time(12,12,12));
```
以上的代码是获取每一天中12点12分12秒发表的所有文章。
如果涉及到秒的可以参考如下代码
```python
    from datatime import time
    
    s_time = time(15,46,25)
    e_time = time(15,46,26)
    articles = Article.objects.filter(create_time__time__range=(s_time,e_time))
```

更多的关于时间的过滤，请参考 Django 官方文档:
[https://docs.djangoproject.com/en/2.1/ref/models/querysets/#time](https://docs.djangoproject.com/en/2.1/ref/models/querysets/#time)

### isnull

根据值是否为空进行查找。示例代码如下：
```python
    articles = Article.objects.filter(pub_date__isnull=False)
```
以上的代码的意思是获取所有发布日期不为空的文章。将来翻译成 `SQL `语句如下：
```sql
    select ... where pub_date is not null;
```

### regex和iregex

大小写敏感和大小写不敏感的正则表达式。示例代码如下：
```python
    articles = Article.objects.filter(title__regex=r'^hello')
```
以上代码的意思是提取所有标题以 `hello `字符串开头的文章。将翻译成以下的 `SQL `语句：
```sql
    select ... where title regexp binary '^hello';
```
`iregex`是大小写不敏感的。


## 根据关联的表进行查询

假如现在有两个 `ORM `模型，一个是 `Article `，一个是 `Category `。代码如下：
```python
    class Category(models.Model):
    """文章分类表"""
        name = models.CharField(max_length=100)
        
    class Article(models.Model):
    """文章表"""
        title = models.CharField(max_length=100,null=True)
        category = models.ForeignKey("Category",on_delete=models.CASCADE)
```
比如想要获取文章标题中包含"hello"的所有的分类。那么可以通过以下代码来实现：
```python
    categories = Category.object.filter(article__title__contains("hello"))
```


## 聚合函数

Django的`django.db.models`模块提供聚合函数。

如果你用原生 `SQL `，则可以使用聚合函数来提取数据。比如提取某个商品销售的数量，那么可以使用 `Count `，如果想要知道商品销售的平均价格，那么可以使用 `Avg `。
聚合函数是通过 `aggregate`方法来实现的。在讲解这些聚合函数的用法的时候，都是基于以下的模型对象来实现的。
```python
    from django.db import models
    class Author(models.Model):
        """作者模型"""
        name = models.CharField(max_length=100)
        age = models.IntegerField()
        email = models.EmailField()
    
        class Meta:
        db_table = 'author'
    
    class Publisher(models.Model):
        """出版社模型"""
        name = models.CharField(max_length=300)
        
        class Meta:
            db_table = 'publisher'
            
    class Book(models.Model):
        """图书模型"""
        name = models.CharField(max_length=300)
        pages = models.IntegerField()
        price = models.FloatField()
        rating = models.FloatField()
        author = models.ForeignKey(Author,on_delete=models.CASCADE)
        publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)
        
        class Meta:
        db_table = 'book'
        
    class BookOrder(models.Model):
        """图书订单模型"""
        book = models.ForeignKey("Book",on_delete=models.CASCADE)
        price = models.FloatField()
        
        class Meta:
        db_table = 'book_order'
```
1. `Avg `：求平均值。比如想要获取所有图书的价格平均值。那么可以使用以下代码实现。
```python
    from django.db.models import Avg
    
    result = Book.objects.aggregate(Avg('price'))
    print(result)
```
以上的打印结果是：
```python
    {"price__avg":23.0}
```
其中 `price__avg `的结构是根据 `field__avg `规则构成的。如果想要修改默认的名字，那么可以将 `Avg `赋值给一个关键字参数。示例代码如下：
```python
    from django.db.models import Avg
    
    result = Book.objects.aggregate(my_avg=Avg('price'))
    print(result)
```
那么以上的结果打印为:
```python
    {"my_avg":23}
```
2. Count ：获取指定的对象的个数。示例代码如下：
```python
    from django.db.models import Count
    
    result = Book.objects.aggregate(book_num=Count('id'))
```
以上的 `result `将返回 `Book `表中总共有多少本图书。`Count `类中，还有另外一个参数叫做 `distinct `，默认是等于 `False `，如果是等于 `True `，那么将去掉那些重复的值。比如要获取作者表中所有的不重复的邮箱总共有多少个，那么可以通过以下代码来实现：
```python
    from djang.db.models import Count
    
    result = Author.objects.aggregate(count=Count('email',distinct=True))
```
3. `Max `和 `Min `：获取指定对象的最大值和最小值。比如想要获取 `Author `表中，最大的年龄和最小的年龄分别是多少。那么可以通过以下代码来实现：
```python
    from django.db.models import Max,Min
    result = Author.objects.aggregate(Max('age'),Min('age'))
```
如果最大的年龄是88,最小的年龄是18。那么以上的result将为：
```python
    {"age__max":88,"age__min":18}
```
4. `Sum `：求指定对象的总和。比如要求图书的销售总额。那么可以使用以下代码实现：
```python
    from djang.db.models import Sum
    result = Book.objects.annotate(total=Sum("bookstore__price")).values("name","total")
```
以上的代码 `annotate `的意思是给 `Book `表在查询的时候添加一个字段叫做 `total `，这个字段的数据来源是从 `BookStore `模型的 `price `的总和而来。 `values `方法是只提取 `name `和 `total `两个字段的值。

更多的聚合函数请参考官方文档:
[https://docs.djangoproject.com/en/2.1/ref/models/querysets/#aggregation-functions](https://docs.djangoproject.com/en/2.1/ref/models/querysets/#aggregation-functions)


## aggregate和anotate的区别

1. `aggregate `：返回使用聚合函数后的字段和值。
2. `annotate `：在原来模型字段的基础之上添加一个使用了聚合函数的字段，并且在使用聚合函数的时候，会使用当前这个模型的主键进行分组（group by）。比如以上 `Sum `的例子，如果使用的是 `annotate `，那么将在每条图书的数据上都添加一个字段叫做 `total `，计算这本书的销售总额。而如果使用的是 `aggregate `，那么将求所有图书的销售总额。


## F表达式和Q表达式


### F表达式

到目前为此的例子中，我们都是将模型字段与常量进行比较。但量，如果想要将模型的一个字段与同一个模型的另外一外字段进行比较该怎么办？
使用Django提供了`F表达式`

`F表达式` 是用来优化 ORM 操作数据库的。比如我们要将公司所有员工的薪水都增加1000元，如果按照正常的流程，应该是先从数据库中提取所有的员工工资到`Python`内存中，然后使用`Python`代码在员工工资的基础之上增加1000元，最后再保存到数据库中。这里面涉及的流程就是，首先从数据库中提取数据到`Python`内存中，然后在`Python`内存中做完运算，之后再保存到数据库中。示例代码如下：
```python
    employees = Employee.objects.all()
    for employee in employees:
    employee.salary += 1000
    employee.save()
```
而我们的 `F表达式`就可以优化这个流程，他可以不需要先把数据从数据库中提取出来，计算完成后再保存回去，他可以直接执行 `SQL`语句 ，就将员工的工资增加1000元。示例代码如下：
```python
    from djang.db.models import F
    Employee.object.update(salary=F("salary")+1000)
```
`F表达式` 并不会马上从数据库中获取数据，而是在生成 `SQL `语句的时候，动态的获取传给 `F表达式` 的值。
比如如果想要获取作者中， `name `和 `email `相同的作者数据。如果不使用 `F表达式` ，那么需要使用以下代码来完成：
```python
    authors = Author.objects.all()
    for author in authors:
        if author.name == author.email:
            print(author)
```
如果使用 `F表达式` ，那么一行代码就可以搞定。示例代码如下：
```python
    from django.db.models import F
    authors = Author.objects.filter(name=F("email"))
```

### Q表达式

普通`filter`函数里的条件都是“and”逻辑，如果你想实现“or”逻辑怎么办？用Q查询！
`Q`来自`django.db.models.Q`，用于封装关键字参数的集合，可以作为关键字参数用于`filter`、`exclude`和`get`等函数。

如果想要实现所有价格高于100元，并且评分达到9.0以上评分的图书。那么可以通过以下代码来实现：
```python
    books = Book.objects.filter(price__gte=100,rating__gte=9)
```
以上这个案例是一个并集查询，可以简单的通过传递多个条件进去来实现。但是如果想要实现一些复杂的查询语句，比如要查询所有价格低于10元，或者是评分低于9分的图书。那就没有办法通过传递多个条件进去实现了。这时候就需要使用 `Q表达式` 来实现了。示例代码:
```python
    from django.db.models import Q
    books = Book.objects.filter(Q(price__lte=10) | Q(rating__lte=9))
```
以上是进行或运算，当然还可以进行其他的运算，比如有 `& `和 `~`（非） 等。一些用 `Q表达式`的例子如下：
```python
    from django.db.models import Q
    
    # 获取id等于3的图书
    books = Book.objects.filter(Q(id=3))
    # 获取id等于3，或者名字中包含文字"记"的图书
    books = Book.objects.filter(Q(id=3)|Q(name__contains("记")))
    # 获取价格大于100，并且书名中包含"记"的图书
    books = Book.objects.filter(Q(price__gte=100)&Q(name__contains("记")))
    # 获取书名包含“记”，但是id不等于3的图书
    books = Book.objects.filter(Q(name__contains='记') & ~Q(id=3))
```

### 缓存与查询集

每个`QuerySet`都包含一个缓存，用于减少对数据库的实际操作。理解这个概念，有助于你提高查询效率。

对于新创建的`QuerySet`，它的缓存是空的。当QuerySet第一次被提交后，数据库执行实际的查询操作，Django会把查询的结果保存在`QuerySet`的缓存内，随后的对于该`QuerySet`的提交将重用这个缓存的数据。

要想高效的利用查询结果，降低数据库负载，你必须善于利用缓存。看下面的例子，这会造成2次实际的数据库操作，加倍数据库的负载，同时由于时间差的问题，可能在两次操作之间数据被删除或修改或添加，导致脏数据的问题：
```python
>>> print([e.headline for e in Entry.objects.all()])
>>> print([e.pub_date for e in Entry.objects.all()])
```
为了避免上面的问题，好的使用方式如下，这只产生一次实际的查询操作，并且保持了数据的一致性：
```python
>>> queryset = Entry.objects.all()
>>> print([p.headline for p in queryset]) # 提交查询
>>> print([p.pub_date for p in queryset]) # 重用查询缓存
```
何时不会被缓存

有一些操作不会缓存QuerySet，例如切片和索引。这就导致这些操作没有缓存可用，每次都会执行实际的数据库查询操作。例如：
```python
>>> queryset = Entry.objects.all()
>>> print(queryset[5]) # 查询数据库
>>> print(queryset[5]) # 再次查询数据库
```
但是，如果已经遍历过整个QuerySet，那么就相当于缓存过，后续的操作则会使用缓存，例如：
```python
>>> queryset = Entry.objects.all()
>>> [entry for entry in queryset] # 查询数据库
>>> print(queryset[5]) # 使用缓存
>>> print(queryset[5]) # 使用缓存
```
下面的这些操作都将遍历QuerySet并建立缓存：
```python
>>> [entry for entry in queryset]
>>> bool(queryset)
>>> entry in queryset
>>> list(queryset)
```
注意：简单的打印QuerySet并不会建立缓存，因为__repr__()调用只返回全部查询集的一个切片。# QuerySet API

我们通常做查询操作的时候，都是通过 `模型名字.objects` 的方式进行操作。其实 `模型名字.objects` 是一个 `django.db.models.manager.Manager` 对象，而 `Manager` 这个类是一个“空壳”的类，他本身是没有任何的属性和方法的。他的方法全部都是通过 `Python`动态添加的方式，从 `QuerySet`类中拷贝过来的。示例图如下：  
![QuerySet API](../images/chapter04/QuerySet_API.png)  
所以我们如果想要学习 `ORM`模型的查找操作，必须首先要学会 `QuerySet`上的一些 API 的使用。

## 返回新的QuerySet方法

在使用 `QuerySet`进行查找操作的时候，可以提供多种操作。比如过滤完后还要根据某个字段进行排序，那么这一系列的操作我们可以通过一个非常流畅的 `链式调用` 的方式进行。比如要从文章表中获取标题为 `123`，并且提取后要将结果根据发布的时间进行排序，那么可以使用以下方式来完  
成：

```python
    articles = Article.objects.filter(title='123').order_by('create_time')
```

可以看到 `order_by`方法是直接在 `filter`执行后调用的。这说明 `filter`返回的对象是一个拥有 `order_by`方法的对象。而这个对象正是一个新的 `QuerySet`对象。因此可以使用 `order_by`方法。  
那么以下将介绍在那些会返回新的 `QuerySet`对象的方法。  
1. `filter`：将满足条件的数据提取出来，返回一个新的 `QuerySet`。具体的 filter 可以提供什么条件查询。请见查询操作章节。  
2. `exclude`：排除满足条件的数据，返回一个新的 `QuerySet`。示例代码如下：

```python
Article.objects.exclude(title__contains='hello')
```

以上代码的意思是提取那些标题不包含 `hello`的图书。  
3. `annotate`：给 `QuerySet`中的每个对象都添加一个使用查询表达式（聚合函数、F表达式、Q表达式、Func表达式等）的新字段。示例代码如下：

```python
    articles = Article.objects.annotate(author_name=F("author__name"))
```

以上代码将在每个对象中都添加一个 author\_\_name 的字段，用来显示这个文章的作者的年龄。  
4. `order_by`：指定将查询的结果根据某个字段进行排序。如果要倒叙排序，那么可以在这个字段的前面加一个**负号**。示例代码如下：

```python
    # 根据创建的时间正序排序
    articles = Article.objects.order_by("create_time")
    # 根据创建的时间倒序排序
    articles = Article.objects.order_by("-create_time")
    # 根据作者的名字进行排序
    articles = Article.objects.order_by("author__name")
    # 首先根据创建的时间进行排序，如果时间相同，则根据作者的名字进行排序
    articles = Article.objects.order_by("create_time",'author__name')
    # 一定要注意的一点是，多个 order_by ，会把前面排序的规则给打乱，而使用后面的排序方式。比如以下代码：
    articles = Article.objects.order_by("create_time").order_by("author__name")
```

他会根据作者的名字进行排序，而不是使用文章的创建时间。  
5. `values`：用来指定在提取数据出来，需要提取哪些字段。默认情况下会把表中所有的字段全部都提取出来，可以使用 `values`来进行指定，并且使用了 `values`方法后，提取出的 `QuerySet`中的数据类型不是模型，而是在 `values`方法中指定的字段和值形成的字典：

```python
articles = Article.objects.values("title",'content')
for article in articles:
print(article)
```

以上打印出来的 `article`是类似于 `{"title":"abc","content":"xxx"}` 的形式。如果在 `values`中没有传递任何参数，那么将会返回这个模型中所有的属性。
如果想要提取的是这个模型上关联的对象的属性，那么就可以，查找顺序`filter`的用法一样。示例代码如下：
```python
    books = Book.objects.values('id','name','author__name')
```  
以上将会提取`author`的`name`字段 ，如果 我们不想要这个名字，想要更改一个名称，那么可以使用关键字参数。示例代码如下：
```python
    books = Book.objects.values('id','name',author_name=F("author__name"))
```
自定义的名字，不能和模型上本身拥有的字段一样。在`values`中，也可以使用聚合函数来形成一个新的字段。想要获取每本图书的销量，示例代码如下：
```python
    books = Book.objects.values('id,'name',sales=Count('bookorder'))
```
6. `values_list`：类似于`values`。只不过返回的`QuerySet`中，存储的不是字典，而是元组。示例代码如下：

```python
    articles = Article.objects.values_list('id','title')
    print(articles)
```

那么在打印`articles`后，结果为`<QuerySet [(1,'abc'),(2,'xxx',...)]>`等。如果在`values_list`中只有一个字段。那么你可以传递`flat=True`来将结果扁平化。示例代码如下:

```python
    articles1 = Article.objects.values_list('title')
    >> <QuerySet [('abc'),('xxx'),...]

    articles2 = Arctile.objects.values_list('title',flat=True)
    >> <QuerySet ['abc','xxx',...]>
```

7 . `all`：获取这个`ORM`模型的`QuerySet`对象。  
8. `select_related`：在提取某个模型的数据的同量，也提前将相关联的数据提取出来。比如提取文章数据，可成为个体`select_related`将`author`信息提取出来，以后再次使用`article.author`的时候就不需要再次去访问数据库了。可以减少数据库查询的次数。示例代码如下：

```python
    article = Article.objects.get(pk=1)
    >> article.author  # 重新执行一次查询语句

    article = Article.objects.select_related('author').get(pk=2)
    >> article.author # 不需要重新执行查询语句了。
```

`select_related`只能用在`一对多`或`一对一`中，不能用在`多对多`或`多对一`中。比如可以提前获取文章的作者，但不能通过作者获取这个作者的文章，或通过某篇文章获取这个文章所有的标签。  
9. `prefetch_related`：这个方法和`select_related`非常的类似，就是在访问多个表中的数据的时候，减少查询的次数。这个方法是为了解决`多对一`和`多对多`的关系的查询问题。比如要获取标题中带有`hello`字符串的文章以及他的所有标签，示例代码如下：

```python
    from django.db import connection

    articles = Article.objects.prefetch_related('tag_set').filter(title__contains='hello')
    print(articles.query)  # 通过这条命令查看在底层的SQL语句

    for article in articles:
        print('title',article.title)
        print(article.tag_set.all())

    # 通过以下代码可以看出来以上代码执行的sql语句
    for sql in connection.queries:
        print(sql)
```

但是如果在使用`article.tag_set`的时候，如果又创建了一个新的`QuerySet`那么会把之前的`SQL`代码给破坏掉。比如下以下代码：

```python
    tags = Tag.obejcts.prefetch_related("articles")
    for tag in tags:
        articles = tag.articles.filter(title__contains='hello') #因为filter方法会重新生成一个QuerySet，因此会破坏掉之前的sql优化

    # 通过以下代码，我们可以看到在使用了filter的，他的sql查询会更多，而没有使用filter的，只有两次sql查询
    for sql in connection.queries:
        print(sql)
```

那如果确实是想要在查询的时候指定过滤条件该如何做呢，这时候我们可以使用`django.db.models.Prefetch`来实现，`Prefetch`这个可以提前定义好`queryset`。示例代码如下：

```python
    tags = Tag.objects.prefetch_related(Prefetch("articles",queryset=Article.objects.filter(title__contains='hello'))).all()
    for tag in tags:
        articles = tag.articles.all()
    for article in articles:
        print(article)

    for sql in connection.queries:
    print('='*30)
    print(sql)
```

因为使用了`Prefetch`，即使在查询文章的时候使用了`filter`，也只会发生两次查询操作。  
10. `defer`：在一些表中，可能存在很多的字段，但是一些字段的数据量可能是比较庞大的，而此时你又不需要，比如我们在获取文章列表的时候，文章的内容我们是不需要的，因此这时候我们就可以使用`defer`来过滤掉一些字段。这个字段跟`values`有点类似，只不过`defer`返回的不是字典，而是模型。示例代码如下：

```python
    articles = list(Article.objects.defer("title"))
    for sql in connection.queries:
        print('='*30)
        print(sql)
```

在看以上代码的`sql`语句，你就可以看到，查找文章的字段，除了`title`，其他字段都查找出来了。当然，你也可以使用`article.title`来获取这个文章的标题，但是会重新执行一个查询的语句。示例代码如下：

```python
    articles = list(Article.objects.defer("title"))
    for article in articles:
        # 因为在上面提取的时候过滤了title
        # 这个地方重新获取title，将重新向数据库中进行一次查找操作
        print(article.title)
    for sql in connection.queries:
        print('='*30)
        print(sql)
```

`defer`虽然能过滤字段，但是有些字段是不能过滤的，比如`id`，即使你过滤了，也会提取出来。  
11. `only`：跟`defer`类似，只不过`defer`是过滤掉指定的字段，而`only`是只提取指定的字段。  
12. `get`：获取满足条件的数据。这个函数只能返回一条数据，并且如果给的条件有多条数据，那么这个方法会抛出`MultipleObjectsReturned`错误，如果给的条件没有任何数据，那么就会抛出`DoesNotExit`错误。所以这个方法在获取数据的只能，只能有且只有一条。  
13. `create`：创建一条数据，并且保存到数据库中。这个方法相当于先用指定的模型创建一个对象，然后再调用这个对象的`save`方法。示例代码如下：

```python
    article = Article(title='abc')
    article.save()

    # 下面这行代码相当于以上两行代码
    article = Article.objects.create(title='abc')
```

14 . `get_or_create`：根据某个条件进行查找，如果找到了那么就返回这条数据，如果没有查找到，那么就创建一个。示例代码如下：

```python
    obj,created= Category.objects.get_or_create(title='默认分类')
```

如果有标题等于默认分类的分类，那么就会查找出来，如果没有，则会创建并且存储到数据库中。这个方法的返回值是一个元组，元组的第一个参数obj是这个对象，第二个参数created代表是否创建的。  
15. `bulk_create`：一次性创建多个数据。示例代码如下：

```python
    Tag.objects.bulk_create([
        Tag(name='111'),
        Tag(name='222'),
    ])
```

16 . `count`：获取提取的数据的个数。如果想要知道总共有多少条数据，那么建议使用`count`，而不是使用`len(articles)`这种。因为`count`在底层是使用`select count(*)`来实现的，这种方式比使用`len`函数更加的高效。  
17. `first`和`last`：返回`QuerySet`中的第一条和最后一条数据。  
18. `aggregate`：使用聚合函数。  
19. `exists`：判断某个条件的数据是否存在。如果要判断某个条件的元素是否存在，那么建议使用`exists`，这比使用`count`或者直接判断`QuerySet`更有效得多。示例代码如下：

```python
    if Article.objects.filter(title__contains='hello').exists():
        print(True)
        # 比使用count更高效：

    if Article.objects.filter(title__contains='hello').count() > 0:
        print(True)
        也比直接判断QuerySet更高效：

    if Article.objects.filter(title__contains='hello'):
        print(True)
```

20 . `distinct`：去除掉那些重复的数据。这个方法如果底层数据库用的是`MySQL`，那么不能传递任何的参数。比如想要提取所有销售的价格超过80元的图书，并且删掉那些重复的，那么可以使用`distinct`来帮我们实现，示例代码如下：

```python
    books = Book.objects.filter(bookorder__price__gte=80).distinct()
```

需要注意的是，如果在`distinct`之前使用了`order_by`，那么因为`order_by`会提取`order_by`中指定的字段，因此再使用`distinct`就会根据多个字段来进行唯一化，所以就不会把那些重复的数据删掉。示例代码如下：

```python
    orders = BookOrder.objects.order_by("create_time").values("book_id").distinct()
```

那么以上代码因为使用了`order_by`，即使使用了`distinct`，也会把重复的`book_id`提取出来。  
21. `update`：执行更新操作，在`SQL`底层走的也是`update`命令。比如要将所有`category`为空的`article`的`article`字段都更新为默认的分类。示例代码如下：

```python
    Article.objects.filter(category__isnull=True).update(category_id=3)
```

注意这个方法走的是更新的逻辑。所以更新完成后保存到数据库中不会执行`save`方法，因此不会更新`auto_now`设置的字段。  
22. `delete`：删除所有满足条件的数据。删除数据的时候，要注意`on_delete`指定的处理方式。  
23. 切片操作：有时候我们查找数据，有可能只需要其中的一部分。那么这时候可以使用切片操作来帮我们完成。`QuerySet`使用切片操作就跟列表使用切片操作是一样的。示例代码如下：

```python
    books = Book.objects.all()[1:3]
    for book in books:
        print(book)
```

切片操作并不是把所有数据从数据库中提取出来再做切片操作。而是在数据库层面使用`LIMIE`和`OFFSET`来帮我们完成。所以如果只需要取其中一部分的数据的时候，建议大家使用切片操作。

### 什么时候Django会将QuerySet转换为SQL去执行：

生成一个`QuerySet`对象并不会马上转换为`SQL`语句去执行。比如我们获取`Book`表下所有的图书：

```python
    books = Book.objects.all()
    print(connection.queries)
```

我们可以看到在打印connection.quries的时候打印的是一个空的列表。说明上面的QuerySet并没有真正的执行。在以下情况下`QuerySet`会被转换为`SQL`语句执行：

* 迭代：在遍历`QuerySet`对象的时候，会首先先执行这个`SQL`语句，然后再把这个结果返回进行迭代。比如以下代码就会转换为`SQL`语句：
  ```python
    for book in Book.objects.all():
        print(book)
  ```
* 使用步长做切片操作：`QuerySet`可以类似于列表一样做切片操作。做切片操作本身不会执行`SQL`语句，但是如果如果在做切片操作的时候提供了步长，那么就会立马执行`SQL`语句。需要注意的是，做切片后不能再执行`filter`方法，否则会报错。
* 调用`len`函数：调用`len`函数用来获取`QuerySet`中总共有多少条数据也会执行`SQL`语句。
* 调用`list`函数：调用`list`函数用来将一个`QuerySet`对象转换为`list`对象也会立马执行`SQL`语句。
* 判断：如果对某个`QuerySet`进行判断，也会立马执行`SQL`语句。

### 不返回QuerySets的API

以下的方法不会返回QuerySets，但是作用非常强大，尤其是粗体显示的方法，需要背下来。

|方法名|	解释|
|---|---|
|**get()**|	获取单个对象|
|**create()**|	创建对象，无需save()|
|**get_or_create()**|	查询对象，如果没有找到就新建对象|
|**update_or_create()**|	更新对象，如果没有找到就创建对象|
|bulk_create()|	批量创建对象|
|**count()**|	统计对象的个数|
|in_bulk()|	根据主键值的列表，批量返回对象|
|iterator()|	获取包含对象的迭代器|
|**latest()**|	获取最近的对象|
|**earliest()**|	获取最早的对象|
|**first()**|	获取第一个对象|
|**last()**|	获取最后一个对象|
|**aggregate()**|	聚合操作|
|**exists()**|	判断queryset中是否有对象|
|**update()**|	批量更新对象|
|**delete()**|	批量删除对象|
|as_manager()|	获取管理器|

## ORM模型迁移

### 迁移命令：

1. `makemigrations`：将模型生成迁移脚本。模型所在的`app`，必须放在`settings.py`中的`INSTALLED_APPS`中。这个命令有以下几个常用选项：
    + `app_label`：后面可以跟一个或者多个`app`，那么就只会针对这几个`app`生成迁移脚本。如果没有任何的`app_label`，那么会检查`INSTALLED_APPS`中所有的`app`下的模型，针对每一个`app`都生成响应的迁移脚本。
    + `--name`：给这个迁移脚本指定一个名字。
    + `--empty`：生成一个空的迁移脚本。如果你想写自己的迁移脚本，可以使用这个命令来实现一个空的文件，然后自己再在文件中写迁移脚本。
2. `migrate`：将新生成的迁移脚本。映射到数据库中。创建新的表或者修改表的结构。以下一些常用的选项：
    + `app_label`：将某个`app`下的迁移脚本映射到数据库中。如果没有指定，那么会将所有在`INSTALLED_APPS`中的`app`下的模型都映射到数据库中。
    + `app_label migrationname`：将某个`app`下指定名字的`migration`文件映射到数据库中。
    + `--fake`：可以将指定的迁移脚本名字添加到数据库中。但是并不会把迁移脚本转换为`SQL`语句，修改数据库中的表。
    + `--fake-initial`：将第一次生成的迁移文件版本号记录在数据库中。但并不会真正的执行迁移脚本。
3. `showmigrations`：查看某个`app`下的迁移文件。如果后面没有`app`，那么将查看`INSTALLED_APPS`中所有的迁移文件。
4. `sqlmigrate`：查看某个迁移文件在映射到数据库中的时候，转换的`SQL`语句。

### migrations中的迁移版本和数据库中的迁移版本对不上怎么办？

1. 找到哪里不一致，然后使用`python manage.py --fake [版本名字]`，将这个版本标记为已经映射。
2. 删除指定`app`下`migrations`和数据库表`django_migrations`中和这个`app`相关的版本号，然后将模型中的字段和数据库中的字段保持一致，再使用命令`python manage.py makemigrations`重新生成一个初始化的迁移脚本，之后再使用命令`python manage.py makemigrations --fake-initial`来将这个初始化的迁移脚本标记为已经映射。以后再修改就没有问题了。

更多关于迁移脚本的。请查看官方文档：
[https://docs.djangoproject.com/en/2.1/topics/migrations/](https://docs.djangoproject.com/en/2.1/topics/migrations/)

### 根据已有的表自动生成模型：

在实际开发中，有些时候可能数据库已经存在了。如果我们用`Django`来开发一个网站，读取的是之前已经存在的数据库中的数据。那么该如何将模型与数据库中的表映射呢？根据旧的数据库生成对应的`ORM`模型，需要以下几个步骤：
1. `Django`给我们提供了一个`inspectdb`的命令，可以非常方便的将已经存在的表，自动的生成模型。想要使用`inspectdb`自动将表生成模型。首先需要在`settings.py`中配置好数据库相关信息。不然就找不到数据库。示例代码如下：
```python
    DATABASES = {
     'default': {
         'ENGINE': 'django.db.backends.mysql',
         'NAME': "migrations_demo",
         'HOST': '127.0.0.1',
         'PORT': '3306',
         'USER': 'root',
         'PASSWORD': 'root'
         }
     }
```
比如有以下表：
    + article表
    + tag表
    + article_tag表
    + front_user表
那么通过`python manage.py inspectdb`，就会将表转换为模型后的代码，显示在终端：
```python
    from django.db import models

    class ArticleArticle(models.Model):
        title = models.CharField(max_length=100)
        content = models.TextField(blank=True, null=True)
        create_time = models.DateTimeField(blank=True, null=True)
        author = models.ForeignKey('FrontUserFrontuser', models.DO_NOTHING, blank=True, null=True)

        class Meta:
            managed = False
            db_table = 'article_article'
    
    class ArticleArticleTags(models.Model):
        article = models.ForeignKey(ArticleArticle, 
```
以上代码只是显示在终端。如果想要保存到文件中。那么可以使用>重定向输出到指定的文件。比如让他输出到`models.py`文件中。示例命令如下：
```python
    python manage.py inspectdb > models.py
```
以上的命令，只能在终端执行，不能在`pycharm->Tools->Run manage.py Task...`中使用。
如果只是想要转换一个表为模型。那么可以指定表的名字。示例命令如下：
```python
    python manage.py inspectdb article_article > models.py
```

2 . 修正模型：新生成的ORM模型有些地方可能不太适合使用。比如模型的名字，表之间的关系等等。那么以下选项还需要重新配置一下： 
    + 模型名：自动生成的模型，是根据表的名字生成的，可能不是你想要的。这时候模型的名字你可以改成任何你想要的。
    + 模型所属`app`：根据自己的需要，将相应的模型放在对应的app中。放在同一个`app`中也是没有任何问题的。只是不方便管理。
    + 模型外键引用：将所有使用`ForeignKey`的地方，模型引用都改成字符串。这样不会产生模型顺序的问题。另外，如果引用的模型已经移动到其他的app中了，那么还要加上这个app的前缀。
    + 让`Django`管理模型：将`Meta`下的`managed=False`删掉，如果保留这个，那么以后这个模型有任何的修改，使用`migrate`都不会映射到数据库中。
    + 当有多对多的时候，应该也要修正模型。将中间表注视了，然后使用`ManyToManyField`来实现多对多。并且，使用`ManyToManyField`生成的中间表的名字可能和数据库中那个中间表的名字不一致，这时候肯定就不能正常连接了。那么可以通过`db_table`来指定中间表的名字。示例代码如下：
    ```python
        class Article(models.Model):
            title = models.CharField(max_length=100, blank=True, null=True)
            content = models.TextField(blank=True, null=True)
            author = models.ForeignKey('front.User', models.SET_NULL, blank=True, null=True)
            # 使用ManyToManyField模型到表，生成的中间表的规则是：article_tags
            # 但现在已经存在的表的名字叫做：article_tag
            # 可以使用db_table，指定中间表的名字
            tags = models.ManyToManyField("Tag",db_table='article_tag')
            
            class Meta:
                db_table = 'article'
    ```
    + 表名：切记不要修改表的名字。不然映射到数据库中，会发生找不到对应表的错误。
    
3 . 执行命令`python manage.py makemigrations`生成初始化的迁移脚本。方便后面通过`ORM`来管理表。这时候还需要执行命令`python manage.py migrate --fake-initial`，因为如果不使用`--fake-initial`，那么会将迁移脚本会映射到数据库中。这时候迁移脚本会新创建表，而这个表之前是已经存在了的，所以肯定会报错。此时我们只要将这个`0001-initial`的状态修改为已经映射，而不真正执行映射，下次再`migrate`的时候，就会忽略他。
4 . 将`Django`的核心表映射到数据库中：`Django`中还有一些核心的表也是需要创建的。不然有些功能是用不了的。比如`auth`相关表。如果这个数据库之前就是使用`Django`开发的，那么这些表就已经存在了。可以不用管了。如果之前这个数据库不是使用`Django`开发的，那么应该使用`migrate`命令将`Django`中的核心模型映射到数据库中。
    
    # ORM作业

假设有以下`ORM`模型：
```python
    from django.db import models
    
    class Student(models.Model):
        """学生表"""
        name = models.CharField(max_length=100)
        gender = models.SmallIntegerField()
        
        class Meta:
        db_table = 'student'
    
    class Course(models.Model):
        """课程表"""
        name = models.CharField(max_length=100)
        teacher = models.ForeignKey("Teacher",on_delete=models.SET_NULL,null=True)
        class Meta:
        db_table = 'course'
    
    class Score(models.Model):
        """分数表"""
        student = models.ForeignKey("Student",on_delete=models.CASCADE)
        course = models.ForeignKey("Course",on_delete=models.CASCADE)
        number = models.FloatField()
        class Meta:
        db_table = 'score'
        
    class Teacher(models.Model):
        """老师表"""
        name = models.CharField(max_length=100)
        class Meta:
        db_table = 'teacher'
```
使用之前学到过的操作实现下面的查询操作：
1. 查询平均成绩大于60分的同学的id和平均成绩；
2. 查询所有同学的id、姓名、选课的数量、总成绩；
3. 查询姓“李”的老师的个数；
4. 查询没学过“李老师”课的同学的id、姓名；
5. 查询学过课程id为1和2的所有同学的id、姓名；
6. 查询学过“黄老师”所教的“所有课”的同学的id、姓名；
7. 查询所有课程成绩小于60分的同学的id和姓名；
8. 查询没有学全所有课的同学的id、姓名；
9. 查询所有学生的姓名、平均分，并且按照平均分从高到低排序；
10. 查询各科成绩的最高和最低分，以如下形式显示：课程ID，课程名称，最高分，最低分；
11. 查询没门课程的平均成绩，按照平均成绩进行排序；
12. 统计总共有多少女生，多少男生；
13. 将“黄老师”的每一门课程都在原来的基础之上加5分；
14. 查询两门以上不及格的同学的id、姓名、以及不及格课程数；
15. 查询每门课的选课人数；# ORM作业参考答案

1. 查询平均成绩大于60分的同学的id和平均成绩
   ```python
    rows = Student.objects.annotate(avg=Avg("score__number")).filter(avg__gte=60).values("id","avg")
    for row in rows:
        print(row)
   ```
2. 查询所有同学的id、姓名、选课的数、总成绩
   ```python
    rows = Student.objects.annotate(course_nums=Count("score__course"),total_score=Sum("score__number")).values("id","name","course_nums","total_score")
    for row in rows:
        print(row)
   ```
3. 查询姓“李”的老师的个数
   ```python
    teacher_nums = Teacher.objects.filter(name__startswith="李").count()
    print(teacher_nums)
   ```
4. 查询没学过“黄老师”课的同学的id、姓名
   ```python
    rows = Student.objects.exclude(score__course__teacher__name="黄老师").values('id','name')
    for row in rows:
        print(row)
   ```
5. 查询学过课程id为1和2的所有同学的id、姓名
   ```python
    rows = Student.objects.filter(score__course__in=[1,2]).distinct().values('id','name')
    for row in rows:
        print(row)
   ```
6. 查询学过“黄老师”所教的所有课的同学的学号、姓名
   ```python
    rows = Student.objects.annotate(nums=Count("score__course",filter=Q(score__course__teacher__name='黄老师'))).filter(nums=Course.objects.filter(teacher__name='黄老师').count()).values('id','name')
    for row in rows:
    print(row)
   ```
7. 查询所有课程成绩小于60分的同学的id和姓名
   ```python
    students = Student.objects.exclude(score__number__gt=60)
    for student in students:
        print(student)
   ```
8. 查询没有学全所有课的同学的id、姓名
   ```python
    students = Student.objects.annotate(num=Count(F("score__course"))).filter(num__lt=Course.objects.count()).values('id','name')
    for student in students:
    print(student)
   ```
9. 查询所有学生的姓名、平均分，并且按照平均分从高到低排序
   ```python
    students = Student.objects.annotate(avg=Avg("score__number")).order_by("-avg").values('name','avg')
    for student in students:
        print(student)
   ```
10. 查询各科成绩的最高和最低分，以如下形式显示：课程ID，课程名称，最高分，最低分
    ```python
    courses = Course.objects.annotate(min=Min("score__number"),max=Max("score__number")).values("id",'name','min','max')
    for course in courses:
        print(course)
    ```
11. 查询每门课程的平均成绩，按照平均成绩进行排序
    ```python
    courses = Course.objects.annotate(avg=Avg("score__number")).order_by('avg').values('id','name','avg')
    for course in courses:
        print(course)
    ```
12. 统计总共有多少女生，多少男生
    ```python
    rows = Student.objects.aggregate(male_num=Count("gender",filter=Q(gender=1)),female_num=Count("gender",filter=Q(gender=2)))
    print(rows)
    ```
13. 将“黄老师”的每一门课程都在原来的基础之上加5分
    ```python
    rows = Score.objects.filter(course__teacher__name='黄老师').update(number=F("number")+5)
    print(rows)
    ```
14. 查询两门以上不及格的同学的id、姓名、以及不及格课程数
    ```python
    students = Student.objects.annotate(bad_count=Count("score__number",filter=Q(score__number__lt=60))).filter(bad_count__gte=2).values('id','name','bad_count')
    for student in students:
    print(student)
    ```
15. 查询每门课的选课人数
    ```python
    courses = Course.objects.annotate(student_nums=Count("score__student")).values('id','name','student_nums')
    for course in courses:
        print(course)
    ```



## Pycharm配置连接数据库

1. 进入`Pycharm`后，右边有一个`Database`的选项，点击这个选项弹出以下界面：
![Database](../images/chapter04/001.png)
2. 然后点击加号（`+`）按钮，会出现以下界面：
![Add](../images/chapter04/002.png)
3. 这时选择`MySQL`，然后会弹出以下配置`MySQL`的对话框
![MySQL1](../images/chapter04/003.png)
4. 填入相故意的信息，然后点击`Test Connection`
![MySQL2](../images/chapter04/004.png)

## 管理器类(Manager)

Django中的`Manager`类是我们通过模型类去操作数据库的工具，Django给每个定义的模型默认添加一个名为`objects`的`Manager`类的对象。

Djang官方文档对`Manager`的概述如下：
> A Manager is the interface through which database query operations are provided to Django models. At least one Manager exists for every model in a Django application.


先看一个对管理器的基本使用，定义一个基本的图书信息类：
```python
class BookInfo(models.Model):
    btitle = models.CharField(max_length=20)
    bpub_date = models.DateField()
    bread = models.IntegerField(default=0)
    bcomment = models.IntegerField(default=0)
    bisDelete = models.BooleanField(default=False)
    def __str__(self):
        return self.btitle
```

接下来我们要查询BookInfo中的所有图书
```python
BookInfo.objects.all()
```

执行完上述查询语句之后，假设我们现在又接收到一个客户端的要求，要求删除一本书，执行下面的代码对数据库执行逻辑删除操作：
```python
book = BookInfo.object.get(btitle='笑傲江湖')
book.bisDelete = 1
book.save()
```

以后我们再执行查询所有图书的信息时，就需要去掉被删除的图书。一种做法就是每次查询所有的图书信息然后去掉`bisDelete`字段为`1`的记录
```python
BookInfo.objects.all().exclude(bisDelete=1)
```

但是我们第次操作都需要写一次上面的代码未免太麻烦了，并且我们要查询的所有的图书信息时本来就默认去掉被删除的图书的信息，而`objects`这个管理器类中的`all`方法是把所有的信息都返回，显然不能满足我们的需求，这个时候我们就需要去自定义管理器类去重新实现`all`方法。


### 自定义管理器类

```python
class BookManager(models.Manager):
        #重写父类的all方法
        def all(self):
            all_data = super().all()
            return all_data.exclude(bisDelete=1)

class BookInfo(models.Model):
    btitle = models.CharField(max_length=20)
    bpub_date = models.DateField()
    bread = models.IntegerField(default=0)
    bcomment = models.IntegerField(default=0)
    bisDelete = models.BooleanField(default=False)
    def __str__(self):
        return self.btitle
    #实例化自定义管理器类(此时默认的objects管理类对象已经失效)
    bmanager = BookManager()

#使用自定义管理类

>>> BookInfo.bmanager.all()

```

### 扩展管理器类功能

前面我们通过自定义管理器类扩展了原有的`all()`方法，但是有的时候我们想要的功能在管理器类中不仅不具备相应的方法，甚至连类似的可继承扩展的方法都没有，这个时候我们就需要完全自定义一个方法了。比如下面的一个场景，我们不希望每次拿到的返回结果都是`QuerySet`类型的集合对象，我们希望每次查询返回的是一个包含满足条件的图书名的`列表`，这个时候我们可以在自定义管理器类中定义一个方法完全适配我们要求的方法(其实这种自定义扩展方法本质就是把对`Manager`管理类查询结果的过滤操作从类外面搬到了管理类内部)
```python
class BookManager(models.Manager):
        # 查询大于给定id号的图书信息
        def blist(self,id):
            ls = []
            all_data = super().filter(id__gt=id)
            for book in all_data:
                ls.append(book.btitle)
            return ls
    #进行测试
    >>> BookInfo.bmanager.blist(2)
```